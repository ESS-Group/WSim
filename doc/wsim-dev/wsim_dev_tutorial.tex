\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{url}


\topmargin 0pt
\advance \topmargin by -\headheight
\advance \topmargin by -\headsep
\textheight 8.9in
\oddsidemargin 0pt
\evensidemargin \oddsidemargin
\marginparwidth 0.5in
\textwidth 6.5in



\title{\huge{WSim tutorial for developers}}
\author{Loic Lemaitre}


\begin{document}
  \maketitle

\abstract{This document is aimed to help developers that would like to create or complement modules on WSim. It is not a full description of WSim source code, but a short introduction to allow to understand its architecture. It also gives some ways to debug your WSim code.}

  \tableofcontents

\chapter{Directories list}

WSim source code directory (\verb$wsim/$) contains the following subdirectories :
\begin{itemize}
  \item \verb$arch/$: implementation of the two supported MCU (MSP430 and ATMEGA).

  \item \verb$autom4te.cache/$:

  \item \verb$devices/$: implementation of external peripherals.

  \item \verb$doc/$: wsim website sources.

  \item \verb$examples/$: example codes to demonstrate WSim main features

  \item \verb$libconsole/$: carries out the link with wconsole.

  \item \verb$libelf/$:

  \item \verb$libetrace/$: deals with the trace generation for eSimu.

  \item \verb$libgdb/$: carries out the link with the gdb debugger.

  \item \verb$libgui/$: used to show user interface (i.e. the leds blinking).

  \item \verb$liblogger/$: deals with error and output messages (wsim.log, error message on terminal).

  \item \verb$ibselect/$: manages inputs and outputs of external devices

  \item \verb$libtracer/$: generates Wsim traces (*.trc).

  \item \verb$libwsnet/$: carries out the link with wsnet.

  \item \verb$machine/$: make the link between platform model and simulator

  \item \verb$platforms/$: implementation of the different platforms (wsn430, telosb, senslab...).

  \item \verb$src/$: point of entry of the program. Deal with the wsim options (arguments) too.

  \item \verb$utils/$: contains compilable sources of useful tools (wtracer, wconsole, ...)
\end{itemize}


\chapter{Program execution overview}

The point of entry of the program is the \verb$main.c$ file located in the \verb$src/$ directory. The program starts by adding base options and specific options of the platform.
Simulation steps :

\begin{figure}[ht]
\begin{center}
 \includegraphics[scale=0.4]{figures/wsim_diag.eps}
\end{center}
\caption{WSim execution diagram}
\label{wsim diagram}
\end{figure}


\chapter{Main internal features management}

\section{Memory}
\subsection{General}
Two states of the platform are stored at any time: the present state and the previous state (called backup in the program).\\

The memory allocation for these two states is carried out by the \verb$devices_memory_allocate()$ function of the \verb$devices.c$ file, located in the \verb$/devices$ directory. This function is called by the platform description file.
In this function, the needed space to save the states of every platform device is computed, in order to store all the data in a contiguous memory spaces.  The pointers to access to them are stored the \verb$machine.devices_state$ and the \verb$machine.devices_state_backup$.\\

This enables to recover easily the previous state (backup) of the whole devices for backtracks.

\subsection{Backtracks}
Backtracks are used when WSim operates with WSnet. Indeed WSim may need to backtrack in two different cases:
\begin{itemize}
  \item when one of the WSim nodes runs beyond an appointment. An other appointment is then set, and the state of the node is restored to the last state saved;
  \item when one of the WSim is in debugging mode, and stopped at a breakpoint, the other nodes are still running. As soon as the WSim node in debugging mode is running again, the other nodes are backtracked.

\end{itemize}
\begin{figure}
\begin{center}
  \includegraphics[scale=1]{figures/wsim_backtrack1.eps}
\end{center}
\caption{WSim backtrack when a node runs beyond an appointment}
\label{wsim backtrack 1}
\end{figure}

\begin{figure}
\begin{center}
  \includegraphics[scale=1]{figures/wsim_backtrack2.eps}
\end{center}
\caption{WSim backtrack in debugging mode}
\label{wsim backtrack 2}
\end{figure}

\verb$void machine_state_save()$

To come back form the present state to the backup one, \verb$void machine_state_restore()$ of the \verb$/machine/machine.c$ file is invoked. This function performs the following main tasks:
\begin{itemize}
  \item setting the time simulation to the time of the backup
  \item replacing the content of the present state memory by the content of the backup state one
  \item restoring traces
  \item restoring wsnet state
\end{itemize}

\section{Signals}
\verb$/arch/common/mcu.h$

\section{I/O}
\verb$/libselect$


\chapter{Implementing new WSim modules}

\section{Platform}
\subsection{Implementing your platform}
\subsubsection{List of mandatory functions to implement}
\begin{itemize}
  \item \verb$int devices_options_add(void)$
  \item \verb$int system_reset (int dev)$
  \item \verb$int system_delete(int dev)$
  \item \verb$int system_create(int dev_num)$
  \item \verb$int devices_create(void)$
  \item \verb$int devices_reset_post(void)$
  \item \verb$int devices_update(void)$
\end{itemize}

\subsubsection{Ordering intructions in devices\_create function}

\subsubsection{Ordering intructions in devices\_update function}

\subsubsection{Managing one or several SPI connections}

\subsubsection{SDL/ui - Input}

\subsection{Making your platform executable}
Makefile - autoconf.ac



\section{Device}
\subsection{Adding a new device model}
\subsubsection{List of mandatory functions to implement}
\begin{itemize}
  \item \verb$int nameofthedevice_add_options()$ : enables to add device specific options when starting a simulation.
  \item \verb$int nameofthedevice_device_size()$ : returns size the device structure needs to store its internal states.
  \item \verb$int nameofthedevice_device_create()$ : 

\end{itemize}

\subsection{GPIO interface management}

\subsection{SPI interface management}
\subsubsection{General}
The SPI interface is implemented in the file \verb$arch/msp430/msp430_usart.c$ for the MSP430 MCU.

\subsubsection{Particular case}
Although WSim tries to be as close as possible to harware it simulates, it may remain some differences. That is sometimes the case of the SPI and device communication simulation, depending of the device implementation.\\

In effect when a byte is written in the SPI UxTXBUF register, this one is sent bit by bit to the SPI linked device, and simultaneously this one replies bit by bit to the UxRXBUF register. Similarly, a dummy byte must be written in the UxTXBUF in order to read data from a SPI device.\\

Concerning WSim, in the plateform description file, the following order must be respected in the \verb$device_update()$ function, as explained previously : write device from MCU, read device from MCU, update device.
Now, for some devices (cc2420, cc1100, ...), writing on their SPI input (SI) is taken into consideration only when the device is updated at the end of a cycle. As the read action is performed after the write one, no response is sent on the device SPI output (SO) yet.\\

This leads to a small lag between the simulation and the reality, since the SPI UxRXBUF register receives the response on the next \verb$device_update()$ call, that is to say few MCU cycles later (from 1 to 6).
The figure~\ref{wsim spi communication} illustrates that.\\

\begin{figure}[!h]
\begin{center}
  \includegraphics[scale=1]{figures/wsim_spi.eps}
\end{center}
\caption{WSim SPI and device communation particular case}
\label{wsim spi communication}
\end{figure}

In most cases this small lag will not be annoying. But if you want to avoid or fix it, you have to write or correct the device model, so that writing and reading on SPI ports trigger immediately an update.


\subsection{I2C}
Not implemented yet!

\section{Special device}
\subsection{Pseudo serial PTTY}


\section{Microcontrolor}


\chapter{Debugging WSim}

There are several methods to debug WSim code source.

\section{wsim.log file}

At each simulation a log file is generated by WSim, named wsim.log and located in the directory where WSim has been launched. This file contains debugging information.
To enable debugging information, you have to define the macro DEBUG. There are two ways to do so :

\begin{itemize}
  \item when launching \verb$configure$ file before compiling WSim add the option \verb$./configure --enable-debug$;
  \item or define directly the macro \verb$DEBUG$ in the WSim file \verb$xxx_debug.h$ located in the same directory than the file you want to debug, as shown in the following example:
\end{itemize}

\begin{verbatim}
/**
 *  \file   cc2420_debug.h
 *  \brief  CC2420 debug messages 
 *  \author Nicolas Boulicault
 *  \date   2007
 **/

/*
 *  cc1100_debug.h
 *  
 *
 *  Created by Nicolas Boulicault on 04/06/07.
 *  Copyright 2007 __WorldSens__. All rights reserved.
 *
 */

#ifndef _CC2420_DEBUG_H_
#define _CC2420_DEBUG_H_

/***************************************************/
/***************************************************/
/***************************************************/

#define DEBUG
#if defined(DEBUG)
#define CC2420_DEBUG(x...)     VERBOSE(2,x)
#define CC2420_DBG_RX(x...)    VERBOSE(2,x)
#define CC2420_DBG_TX(x...)    VERBOSE(2,x)
#else
#define CC2420_DEBUG(x...)     do { } while (0)
#define CC2420_DBG_RX(x...)    do { } while (0)
#define CC2420_DBG_TX(x...)    do { } while (0)
#endif

/***************************************************/
/***************************************************/
/***************************************************/

#define CC2420_PINS_DEBUG

\end{verbatim}

The second method has the avantage to print only debug messages of the file where \verb$DEBUG$ is defined, contrary to the first one that behaves like \verb$DEBUG$ were defined in each file of the program.

By default, debugging information in wsim.log file is minimal.(default verbose level equal to 0). Nevertheless more information may be output be increasing verbose level when starting simulation : \verb$--verbose=6$ for instance.
In the previous code, we have \verb$#define CC2420_DBG_RX(x...)    VERBOSE(2,x)$. This means that the \verb$CC2420_DBG_RX$ will be print in the wsim.log file only if the verbose level is superior or equal to 2.

Thus you understand that it is quite easy to add your own debug informations, if you need. You just have to define the print debugging function with its verbose level at the beginning of your file (or its associated *.h file). Then insert it with appropiate debugging message (like a \verb$printf()$ function) at the right place.

Notice that the wsim.log file name may be changed into nameofyourchoice.log by using the option \verb$--logfile=nameofyourchoice.log$.

\section{The ERROR() function}
The \verb$ERROR()$ function is closed to the \verb$VERBOSE()$ function, excepted that its result is printed in the wsim.log file and in the standard error output too, that is to say the terminal you launch WSim.
You can insert \verb$ERROR()$ function where you want without needs to declare it. Its syntax is like a \verb$printf()$ function.
Moreover some ERROR messages are printed only if the macro \verb$DEBUG_ME_HARDER$ is defined :
\begin{verbatim}
#if defined(DEBUG_ME_HARDER)
	    ERROR("senslab:devices: read data on radio while not in SPI mode ?\n");
#endif
\end{verbatim}

\section{Wsim trace}
The \verb$tracer_event_record()$ function, insered in the Wsim code, allows to save states of a variable during the simulation. To enable the trace storage, you just have to add the following option when starting a simulation: \verb$--trace$ (example: \verb$wsim-wsn430 --ui --trace --mode=time --modearg=100000000000$ \verb$wsn430-leds.elf$). The trace is then stored in the \verb$wsim.trc$ file and located in the  directory where WSim has been launched.

To make the wsim.trc file usable, you have to convert it with the external wtracer application, according to the following syntax. For instance:
\begin{itemize}
  \item\verb$wtracer --in=wsim.trc --out=wsim.gp --format=gplot$ gererates the gnuplot wsim.gp file. 
  \item\verb$wtracer --in=wsim.trc --out=wsim.vcd --format=vcd$ gererates the vcd wsim.vcd file, readable by GTKwave.
\end{itemize}


\section{Using GDB}
It is also possible to debug WSim by using GDB. Launch GDB in the folder where the *.elf file is located, set your breakpoints, and execute the run command followed by the WSim arguments, including your *.elf file. Here is an example:
\begin{verbatim}
loic@loic-laptop:~/Documents/Senstools/temp/senslab/node/wsn430_SW/wsn430-drivers/
wsn430-cc2420\$ gdb wsim-senslabv14
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu"...
(gdb) b main.c:200
Breakpoint 1 at 0x8054568: file main.c, line 200.
(gdb) r cc2420-tx.elf 
Starting program: /usr/local/bin/wsim-senslabv14 cc2420-tx.elf
[Thread debugging using libthread_db enabled]
[New Thread 0xb7c168c0 (LWP 23589)]
[Switching to Thread 0xb7c168c0 (LWP 23589)]

Breakpoint 1, main (argc=2, argv=0xbf976f24) at main.c:200
200	  options_start();
(gdb) n
201	  ui_options_add();
(gdb) 
\end{verbatim}


\chapter{Appendix}

\section{Glossary}
\begin{itemize}
  \item MCU = microcontroller
  \item SI = SPI device input
  \item SO = SPI device output
  \item UxRXBUF = SPI register used for reception
  \item UxTXBUF = SPI register used for transmission
\end{itemize}



\end{document}          
