\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{color}
\usepackage{url}
\usepackage{colortbl}

\topmargin 0pt
\advance \topmargin by -\headheight
\advance \topmargin by -\headsep
\textheight 8.9in
\oddsidemargin 0pt
\evensidemargin \oddsidemargin
\marginparwidth 0.5in
\textwidth 6.5in


\title{\huge{WSim tutorial for developers}}
\author{Loic Lemaitre}


\begin{document}
  \maketitle

\abstract{This document is aimed to help developers that would like to create or complement modules on WSim. It is not a full description of WSim source code, but a short introduction to allow to understand its architecture. It also gives some ways to debug your WSim code.}

  \tableofcontents

\chapter{Directories list}

WSim source code directory (\verb$/wsim$) contains the following subdirectories:
\begin{itemize}
  \item \verb$/arch$: implementation of the two supported MCU (MSP430 and ATMEGA).

  \item \verb$/autom4te.cache$:

  \item \verb$/devices$: implementation of external peripherals;

  \item \verb$/doc$: wsim website sources;

  \item \verb$/examples$: example codes to demonstrate WSim main features;

  \item \verb$/libconsole$: handles the WSim console mode;

  \item \verb$/libelf$: interface with the \verb$*.elf$ program

  \item \verb$/libetrace$: deals with the trace generation for eSimu;

  \item \verb$/libgdb$: carries out the link with the gdb debugger;

  \item \verb$/libgui$: used to show user interface (i.e. the leds blinking);

  \item \verb$/liblogger$: deals with error and output messages (wsim.log, error message on terminal);

  \item \verb$/libselect$: manages inputs and outputs between WSim and external application (WConsole, WSnet);

  \item \verb$/libtracer$: generates WSim traces (\verb$*.trc$);

  \item \verb$/libwsnet$: carries out the link with WSnet application;

  \item \verb$/machine$: make the link between platform model and simulator;

  \item \verb$/platforms$: implementation of the different platforms (wsn430, telosb, senslab...);

  \item \verb$/src$: point of entry of the program. Deal with the wsim options (arguments) too;

  \item \verb$/utils$: contains compilable sources of useful tools (WTracer, WConsole, ...);
\end{itemize}


\chapter{Program execution overview}
\label{prog-exec}

The point of entry of the program is the \verb$main.c$ file located in the \verb$src/$ directory.

\section{Initialisation}
The initialisation is carried out in the \verb$main()$ function of the previous named file.
\begin{enumerate}
  \item Program starts by adding program options and specific options of the platform (given on command line);      
  \item Next step is the initialisation of WSim modules: log messages handler (liblogger), interface with external applications (libselect), traces handler (libtracer and libetrace);
  \item The machine is then created: machine structure initialisation, and platform (MCU + devices) creation;
  \item The *.elf program is loaded (if WSim is not in debugging mode);
  \item Display is created if requested;
  \item tracer and etracer are started if requested;
  \item WSim is ready to run.
\end{enumerate}

\section{Running}
WSim supports 5 different simulation modes:
\begin{itemize}
  \item \textbf{Standard run}: simulation runs until the end of the *.elf program;
  \item \textbf{Instruction}: simulation runs for a predefined number of MCU instruction;
  \item \textbf{Time}: simulation runs for a predefined time;
  \item \textbf{GDB}: simulation runs in debugging mode, being remoted by GDB;
  \item \textbf{Console}: enables to handle simulation execution from a command line.
\end{itemize}

At the end of the \verb$main.c$ function, the  \verb$main_run_mode()$ function of the same file is called, in order to select the right simulation mode. At this time WSim is going to execute the first instruction of the *.elf program. Diagram \ref{wsim-instruction} presents the steps of one instruction execution.

\begin{figure}[ht]
\begin{center}
  \includegraphics[scale=0.8]{figures/wsim_diag_execution.eps}
\end{center}
\caption{Steps of one instruction execution}
\label{wsim-instruction}
\end{figure}

The core of the instruction execution is the \verb$msp430_mcu_run_insn()$ function of the\\ \verb$/arch/msp430/msp430_alu.c$ file. This function fetchs, decodes, executes one instruction, launches devices update and IRQ consideration (performed by \verb$msp430_mcu_update()$ function).

If the MCU is in low power mode \verb$msp430_mcu_run_lpm()$ of the \verb$/arch/msp430/msp430_alu.c$ file is called instead of \verb$msp430_mcu_run_insn()$.\\

Next paragraph describes the called functions chains, for each WSim mode, to get from the \verb$main.c$ file to the execution of one instruction.
\begin{itemize}
  \item Standard run: \verb$machine_run_free()$ $\longrightarrow$ \verb$machine_run()$ $\longrightarrow$ \verb$mcu_run()$ $\longrightarrow$ \verb$msp430_mcu_run_insn()$ or \verb$msp430_mcu_run_lpm()$ $\longrightarrow$ \verb$msp430_mcu_update()$;
  \item Instruction mode: \verb$machine_run_insn()$ $\longrightarrow$ \verb$machine_run()$ $\longrightarrow$ \verb$mcu_run()$ $\longrightarrow$ \\\verb$msp430_mcu_run_insn()$ or \verb$msp430_mcu_run_lpm()$ $\longrightarrow$ \verb$msp430_mcu_update()$;
  \item Time mode: \verb$machine_run_time$ $\longrightarrow$ \verb$machine_run()$ $\longrightarrow$ \verb$mcu_run()$ $\longrightarrow$ \verb$msp430_mcu_run_insn()$ or \verb$msp430_mcu_run_lpm()$ $\longrightarrow$ \verb$msp430_mcu_update()$;
  \item GDB mode: \verb$libgdb_target_mode_main()$ $\longrightarrow$ \verb$gdbremote_getcmd()$ $\longrightarrow$ \verb$gdbremote_single_step()$ or \verb$gdbremote_continue()$ $\longrightarrow$ \verb$machine_run_free()$ $\longrightarrow$ \verb$machine_run()$ $\longrightarrow$ \verb$mcu_run()$ $\longrightarrow$\\ \verb$msp430_mcu_run_insn()$ or \verb$msp430_mcu_run_lpm()$ $\longrightarrow$ \verb$msp430_mcu_update()$;
  \item Console mode: \verb$console_mode_main()$ $\longrightarrow$ \verb$console_command()$, then WSim starts one of the four previous mode, depending of the text string you enter on the command line.
\end{itemize}

\section{End of the simulation}
The simulation normally ends if one of these cases is true:
\begin{itemize}
  \item the \verb$*.elf$ program is finished;
  \item an illegal instruction has been detected in the \verb$*.elf$ program;
  \item the exact number of instructions has been executed (only in instructon mode);
  \item the simulation time is over (only in time mode);
  \item "quit" command has been typed (only in console mode);
  \item GBD is closed before the end of the simulation (only in GDB mode).
\end{itemize}

For standard, instruction and time modes, statistics of the simulation are written in the wsim.log file just before leaving WSim. These statistics are general informations about WSim, and more specific about machine, MCU and devices.


\chapter{Main internal features management}

\section{Memory}
\subsection{General}
Main storages are MCU state, platform external devices state (radio, leds, ...), and possibly internal platform state. A backup of these states is periodically carried out so that it allows to recover easily the previous saved state of the platform in order to backtrack.

\subsubsection{Devices and platform}
When a platform is built, an instance of each of its devices is created in order to save its states. The memory allocation  is done by the \verb$devices_memory_allocate()$ function of the \verb$devices.c$ file, located in the \verb$/devices$ directory. This function is called by the platform description file. In this function, the needed space to save the states of every platform device is computed, in order to store all the data in a contiguous memory spaces.  The pointers to access to them are stored into the \verb$machine.devices_state$ and the \verb$machine.devices_state_backup$ (\verb$machine$ is a global structure storing devices states, devices number, devices size and time of simulation).\\

Moreover saving internal platform states may be necessary. They are then stored in a platform specific structure (of your platform file), you have to define. This structure must be saved in the same contiguous space than the devices, by considering it as a device.

\subsubsection{MCU}
The MCU state and its backup are stored into global structures (\verb$mcu$ and \verb$mcu_backup$), since we know the needed space and as there is only one MCU by platform. So we need not indirections (through pointers) to access to the MCU structure, in spite of the device structure.

\subsection{Backtracks}
Backtracks are used when WSim operates with WSnet. Indeed WSim may need to backtrack in two different cases:
\begin{itemize}
  \item when one of WSim nodes runs beyond a meeting point, since nodes synchronisation is done by an appointment method. An other meeting point is then set, and the state of the node is restored to the last state saved;
  \item when one of WSim nodes is in debugging mode, and stopped at a breakpoint, the other nodes are still running. As soon as the WSim node in debugging mode is running again, the other nodes are backtracked.
\end{itemize}

\begin{figure}
\begin{center}
  \includegraphics[scale=1]{figures/wsim_backtrack1.eps}
\end{center}
\caption{WSim backtrack when a node runs beyond a meeting point}
\label{wsim backtrack 1}
\end{figure}

\begin{figure}
\begin{center}
  \includegraphics[scale=1]{figures/wsim_backtrack2.eps}
\end{center}
\caption{WSim backtrack in debugging mode}
\label{wsim backtrack 2}
\end{figure}

State backup saves are performed by WSim nodes through the \verb$void machine_state_save()$ function, as soon as a synchronisation is successfull or a response is received by WSnet from a WSim node. To come back from the present state to the backup one, \verb$void machine_state_restore()$ of the \verb$/machine/machine.c$ file is called. This function executes the following tasks:
\begin{itemize}
  \item restoring the state of the MCU (copy of the MCU structure in the MCU backup structure)
  \item setting the time simulation to the time of the backup
  \item replacing the content of the present state memory by the content of the backup state one
  \item restoring traces
  \item restoring WSnet state
\end{itemize}


\section{Clocks}

MSP430 time resolution is implemented in nanoseconds in WSim. Each time an instruction is executed, the MCLK is incremented and ACLK, ACLKn, SMCLK are computed according to MCLK value.\\

MSP430 clocks functions are written in the \verb$/arch/msp430/msp430_basic_clock.c$ or\\ \verb$/arch/msp430/msp430_fll_clock.c$ depending of the MSP430 model.\\

The figure \ref{wsim-clocks} presents the clocks update chain.

\begin{figure}[!h]
\begin{center}
  \includegraphics[scale=0.9]{figures/wsim_clocks.eps}
\end{center}
\caption{WSim MSP430 clocks design}
\label{wsim-clocks}
\end{figure}

%%%%%%%%%%%%%%%A COMPRENDRE ET AJOUTER%%%%%%%%%%%%%%%%%%%%%
%-Correspond aux é ́ché ́ances du traitement des interruptions
%-Ecriture des modèles de p ́ériph ́ériques en consé ́quences
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\section{Signals}
Signals allows to signal system states switchs or errors on the *elf program executing.

In the \verb$/arch/common/mcu.h$ file you can find this following code with its comments:

\begin{verbatim}
 MCU signals
  ===========

  mcu signal is a 32 bits variable that holds signal and 
  control bitfields

 
   .... .... | .... .... | .... .... | XXXX XXXX  : SIG_MCU_xxxx or HOST_SIGNAL
   .... .... | .... .... | .... ...X | .... ....  : SIG_MCU_LPM_CHANGE
  
   .... .... | .... ...X | .... .... | .... ....  : SIG_MCU          (set if SIG_MCU)
   .... .... | .... ..X. | .... .... | .... ....  : SIG_RUN_INSN     (insn single step mode)
   .... .... | .... .X.. | .... .... | .... ....  : SIG_RUN_TIME     (time single step mode)
   .... .... | .... X... | .... .... | .... ....  : SIG_GDB_SINGLE   (gdb  single step mode)
   .... .... | ...X .... | .... .... | .... ....  : SIG_GDB_IO       (IO TCP/GDB)
   .... .... | ..X. .... | .... .... | .... ....  : SIG_CON_IO       (IO Console)
   .... .... | .X.. .... | .... .... | .... ....  : SIG_WORLDSENS_IO (IO UDB/WSNnet)
   .... .... | X... .... | .... .... | .... ....  : SIG_UI           (IO UI)
  
   .... ...X | .... .... | .... .... | .... ....  : SIG_HOST         (Host signal on WSim)
   .... ..X. | .... .... | .... .... | .... ....  : SIG_MAC          (Memory access control)
   XXXX X... | .... .... | .... .... | .... ....  : SIG_MAC_xxxx


   SIG_MCU 8bits can be set either for an internal MCU signal (identified by the SIG_MCU bit)
   or for an external Unix signal on the WSim process (identified by SIG_HOST bit).

**********************************************************************************************/


/* mcu internal signal id */
#define SIG_MCU_HUP        0x00000001
#define SIG_MCU_INT        0x00000002
#define SIG_MCU_QUIT       0x00000004 /* used */
#define SIG_MCU_ILL        0x00000008 /* used */
#define SIG_MCU_TRAP       0x00000010 /* used */
#define SIG_MCU_ABRT       0x00000020
#define SIG_MCU_BUS        0x00000040 /* used */
#define SIG_MCU_TSTP       0x00000080
#define SIG_MCU_LPM_CHANGE 0x00000100
#define SIG_MCU_ALL        0x000001ff

#define SIG_HOST_SIGNAL    0x000000ff

/* signal source identifier */
#define SIG_MCU            0x00010000 /* mcu internal signal     */
#define SIG_RUN_INSN       0x00020000 /* insn mode               */
#define SIG_RUN_TIME       0x00040000 /* time mode               */
#define SIG_GDB_SINGLE     0x00080000 /* simul trap for GDB      */

#define SIG_GDB_IO         0x00100000 /* gdb tcp io request      */
#define SIG_CON_IO         0x00200000 /* console mode            */
#define SIG_WORLDSENS_IO   0x00400000 /* worldsens network io    */
#define SIG_UI             0x00800000 /* ui signal (keyboard)    */
#define SIG_HOST           0x01000000 /* host signal             */
#define SIG_MAC            0x02000000 /* mem breakpoint          */
#define SIG_BREAK_MEM_XX   0xf0000000 /*                 
\end{verbatim}

This code defines signals values.

\section{I/O}
\verb$/libselect$


\chapter{Implementing new WSim modules}

\section{Platform}
In the WSim design, the platform file is aimed to describe it, but also to make a link between MCU and devices.
\subsection{Implementing your platform}
\subsubsection{Headers to include}
You have to include the following files in your platform implementation:
\begin{itemize}
  \item The MCU common header (\verb$#include "arch/common/hardware.h"$) and the MCU specific header (\verb$#include "arch/msp430/msp430.h"$ or \verb$#include "arch/atmega/atmega128.h"$);
  \item The device common header (\verb$#include "devices/devices.h"$) and the header of each implemented devices of the platform;
  \item \verb$#include "src/options.h"$ if you want to add platform specific options.
\end{itemize}

\subsubsection{List of mandatory functions to implement}
\begin{itemize}
  \item \verb$int devices_options_add(void)$: adds platform specific options with the \verb$option_add()$ function;
  \item \verb$int devices_create(void)$: computes the needed memory space for devices and initialise them;
  \item \verb$int devices_reset_post(void)$: function called after devices reset, so devices init conditions must be written here;	
  \item \verb$int devices_update(void)$: function called after every MCU instruction execution, this function handles input and output between MCU and devices ports.
\end{itemize}

\subsubsection{Intructions in devices\_create() function}
This function is called only once at the simulation initialisation. This intructions sequence should be followed:
\begin{enumerate}
  \item You have first to take into consideration potential specific options, that might have been provided as a command line argument (only if you implement specific option in \verb$devices_option_add()$). This is done by checking the \verb$value$ item of each option structure.
  \item MCU must be initialised by calling its \verb$MCUNAME_create()$ function;
  \item Fix each device size and store it in the \verb$machine.device_size$ table. Now call the \\ \verb$devices_memory_allocate()$ function of the \verb$/devices/devices.c$ file;
  \item Create each device with its \verb$DEVICENAME_device_create()$ function;
  \item Initialise UIs by getting their sizes (\verb$machine.device[DEVICEID].ui_get_id()$) and set their positions (\verb$machine.device[DEVICEID].ui_set_pos()$).
\end{enumerate}

\subsubsection{Intructions in devices\_update() function}
\label{platform-update}
This function is the core of the platform because it describes GPIO and SPI connections between MCU and . Thus every time the MCU decodes an intruction, this function will be called.
Instructions sequence is important and you have to follow this order as explained previously (cf chapter \ref{prog-exec} page \pageref{prog-exec}): MCU to devices transfer, devices to MCU transfer, devices update. Otherwise SPI communications might experience dysfunctions.

\begin{enumerate}
  \item First you begin by reading the MCU pins with this function: \verb$MCUNAME_digiIO_dev_read()$, that reads the 8 pins of a MCU port. Then depending of the devices pins configuration, transfer the received value on the right devices pins, by using \verb$machine.device[DEVICEID].write()$. Reiterate the sequence as many times as the number of MCU ports;
  \item Do the same operation with the UART or/and SPI ports: use \verb$msp430_UARTORSPI+ID_dev_read_$\linebreak\verb$UARTORSPI()$ to get pins value and \verb$machine.device[DEVICEID].write()$ to send it to the connected device;
  \item Now repeat the two first steps in the opposite direction, that is to say from devices to MCU pins. Use  \verb$machine.device[DEVICEID].read()$ to read devices pins and \verb$msp430_usart+ID_dev_write_$\linebreak\verb$UARTORSPI()$ to write MCU SPI or UART pins, or \verb$msp430_digiIO_dev_write()$ to write MCU GPIOs.
  \item Finally these modules must be updated:
  \begin{description}
    \item -libselect to update external I/O of WSim: \verb$LIBSELECT_UPDATE()$;
    \item -libwsnet to update link with WSnet : \verb$LIBWSNET_UPDATE()$;
    \item -platform devices to update their internal states: \verb$machine.device[DEVICEID].update()$ for each device.
  \end{description}
\end{enumerate}

\noindent\underline{Remark:} To make your platform more reliable, and give value-added to the simulation, you may add tests for illegal operations not to happen, for example:
\begin{itemize}
  \item Checking if MCU is in SPI mode before reading a SPI device;
  \item Checking if MCU is in UART mode before reading an UART device;
  \item If there are more than one device on one SPI, checking that their CSs are not enabled at the same time;
  \item Any other test you need...
\end{itemize}


\subsubsection{SDL/UI}

WSim enables you to print on screen an picture associated to your platform. This module is considered as a device, and is thus implemented in the \verb$/devices/uigfx$ folder.


\subsection{Making your platform compilable and executable}
\label{platform-compilation}
To compile WSim, makefiles are generated with the help of the GNU Project Autotools (automake $\ge$ 1.10, autoconf $\ge$ 2.61) \footnote{For further informations please see http://www.gnu.org/software/automake/ and 
http://www.gnu.org/software/autoconf/ websites}.
You have to modify three files to compile your platform : \verb$./configure.ac$, \verb$./platforms/Makefile.am$, \verb$./platforms/YOURPLATFORMFOLDER/Makefile.am$.

\subsubsection{/configure.ac}
\begin{enumerate}
  \item In the \verb$platform model$ part, add an option to enable to compile only your platform by using the command \verb$./configure --enable-platform-yourplatformname$:
\begin{verbatim}
dnl yourplatformname
AC_ARG_ENABLE([platform-yourplatformname],AS_HELP_STRING([--enable-\
platform-yourplatformname],[yourplatformname platform]))
if test "${enable_platform_senslab}" = "yes" ; then
	enable_mcu_msp430=yes  dnl or enable_mcu_atmega=yes
	NPLATFORM=$(($NPLATFORM + 1))
	PLATFORMNAMES="yourplatformname"
fi
\end{verbatim}

  \item And at the end of the \verb$platform model$ part insert the following line:
\begin{verbatim}
AM_CONDITIONAL([BUILD_YOURPLATFORMNAME],   [test "${enable_platform_yourplatformname}"   \
= "yes" -o "$ALL" = "yes" ])
\end{verbatim}
This line initialises the \verb$BUILD_YOURPLATFORMNAME$ variable to \verb$1$ if your platform only or all the platforms must be built, else to \verb$0$ (the purpose of this variable is developped in paragraph \ref{yourplatformmakefile} page \pageref{yourplatformmakefile}).\\

  \item Add the path to your platform makefile into \verb$AC_CONFIG_FILES$ of the output part: 
\begin{verbatim}
platforms/YOURPLATFORMFOLDER/Makefile
\end{verbatim}
\end{enumerate}

\subsubsection{/platforms/Makefile.am}
Simply add the name of your platform directory in the \verb$SUBDIRS$ variable.
\begin{verbatim}
SUBDIRS=wsn430 ot2006 otsetre ez430 tests telosb \
	mosar mica2 micaz iclbsn wisenode senslab yourplatformname
\end{verbatim}

\subsubsection{/platforms/YOURPLATFORMFOLDER/Makefile.am}
\label{yourplatformmakefile}
\begin{enumerate}
  \item First test if your platform must be built or not, thanks to the \verb$BUILD_YOURPLATFORMNAME$ variable defined with the \verb$AM_CONDITIONAL$ command in the \verb$configure.ac$ file: 
\begin{verbatim}
if BUILD_YOURPLATFORMNAME
\end{verbatim}

 \item  Next set the program name and the worldsens program name (program running with WSnet) for your platform:
\begin{verbatim}
bin_PROGRAMS=wsim-yourplatformname
if BUILD_WORLDSENS
bin_PROGRAMS+=worldsens-yourplatformname
endif
\end{verbatim}

  \item This line adds preprocessor arguments (here it enables to include /wsim top directory at compilation):
\begin{verbatim}
INCLUDES=-I$(top_srcdir)
\end{verbatim}

  \item Then define the MCU and devices libraries dependances paths. For instance:
\begin{verbatim}
YOURPLATFORMNAME_MCU= ../../arch/msp430/libmsp430f1611.a
YOURPLATFORMNAME_DEV= ../../devices/led/libled.a        \
                      ../../devices/ds2411/libds2411.a  \
                      ../../devices/m25p80/libm25p80.a  \
                      ../../devices/ptty/libptty.a      \
                      ../../devices/uigfx/libuigfx.a    \
                      ../../devices/cc1100/libcc1100.a
\end{verbatim}

  \item Add specific compilation flags:
\begin{verbatim}
wsim_yourplatformname_CFLAGS=-DMSP430f1611
\end{verbatim}
This flag will define the global macro MSP430f1611 during the compilation.

  \item Declare the name of your platform source file:
\begin{verbatim}
wsim_yourplatformname_SOURCES=yourplatformname.c
\end{verbatim}

  \item Declare the librairies dependances path set below: 
\begin{verbatim}
wsim_yourplatformname_LDADD=${YOURPLATFORMNAME_DEV} ${WSIMADD} ${YOURPLATFORMNAME_MCU}
\end{verbatim}
\verb!${WSIMADD}! is defined in the \verb$/platform/Makefile.am$ file, and sets some general WSim library dependance.

  \item  Finally do not forget to close the \verb$if BUILD_YOURPLATFORMNAME$
\begin{verbatim}
endif
\end{verbatim}

\end{enumerate}

\section{Device}
\subsection{Adding a new device model}
\subsubsection{List of mandatory functions to implement}
\begin{itemize}
  \item \verb$int YOURDEVICENAME_add_options()$: enables to add device specific options when starting a simulation.
  \item \verb$int YOURDEVICENAME_device_size()$: returns size the device structure needs to store its internal states.
  \item \verb$int YOURDEVICENAME_device_create()$: creates an instance of the device, by initialising the states in \verb$machine.device[DEVICEID].data$ and storing in \verb$machine.device[DEVICEID]$ device private functions to be called during the simulation.
\end{itemize}

\subsubsection{List of optional functions to implement}
Depending of devices features some of these private functions have to be implemented:
\begin{itemize}
  \item \verb$int YOURDEVICENAME_write()$: transmits MCU informations to the device
  \item \verb$int YOURDEVICENAME_read()$: transmits device informations to the MCU (for example leds need not this function);
  \item \verb$int YOURDEVICENAME_update()$: updates internal state of the device after read or write action (for instance emptying radio TX buffer after its content has been transmitted to the MCU);
  \item \verb$int YOURDEVICENAME_delete()$: frees memory space filled by the device (excepted the device states);
  \item \verb$int YOURDEVICENAME_reset()$: resets the device (at its default states);
  \item \verb$int YOURDEVICENAME_power_up()$: for potential futur use;
  \item \verb$int YOURDEVICENAME_power_down()$: for potential futur use;
  \item \verb$int YOURDEVICENAME_ui_draw()$: draws device graphical interface;
  \item \verb$int YOURDEVICENAME_ui_set_pos()$: sets the position of device graphical interface;
  \item \verb$int YOURDEVICENAME_ui_get_pos()$: gives the position of device graphical interface;
  \item \verb$int YOURDEVICENAME_ui_get_size()$: gives the size of device graphical interface;
  \item \verb$int YOURDEVICENAME_statdump()$: may be used to return device statistics (called only at the end of the simulation).
\end{itemize}

\subsection{IO pins interface management}
\subsubsection{General}
There are 2 main class of IO, GPIOs for general use, and USART. IO device pins are the interface between device and MCU. In the platform file, these pins are going to be read and write from/to MCU, thanks to read and write device functions as described below. To select the device pin to read or write, a mask variable may be used. For example, the following masks are defined for the M25P80 flash memory device (in the \verb$./devices/m25p80/m25p80.h$ file):

\begin{verbatim}
#define M25P_W_SHIFT  8 /* write protect */
#define M25P_S_SHIFT  9 /* select        */
#define M25P_H_SHIFT 10 /* hold          */
#define M25P_C_SHIFT 11 /* clock         */

#define M25P_D  0x00ff               /** data 8 bits           **/
#define M25P_W  (1 << M25P_W_SHIFT)  /** write protect negated **/
#define M25P_S  (1 << M25P_S_SHIFT)  /** chip select negated   **/
#define M25P_H  (1 << M25P_H_SHIFT)  /** hold negated          **/
#define M25P_C  (1 << M25P_C_SHIFT)  /** clock                 **/
\end{verbatim}

\medskip
Table \ref{m25p80-masks} and figure \ref{wsim-m25p80} clarifies this C code:

\begin{table}[!h]
  \begin{minipage}[b]{0.50\linewidth}
    \begin{center}
    \begin{tabular}{|l|l|l|}
    \hline
      \rowcolor[gray]{0.9} \textbf{Name} & \textbf{Value} & \textbf{Pin(s)} \\
    \hline
      \verb$M25P_D$ & \verb$0000 0000 1111 1111$ & \verb$SPI SDI, SPI SDO$ \\
    \hline
      \verb$M25P_W$ & \verb$0000 0001 0000 0000$ & \verb$FLASH W$ \\
    \hline
      \verb$M25P_S$ & \verb$0000 0010 0000 0000$ & \verb$FLASH CS$ \\
    \hline
      \verb$M25P_H$ & \verb$0000 0100 0000 0000$ & \verb$FLASH HOLD$ \\
    \hline
      \verb$M25P_C$ & \verb$0000 1000 0000 0000$ & \verb$SPI CLOCK$ \\
    \hline
    \end{tabular}
    \end{center}
    \caption{Value of the M25P80 masks}
    \label{m25p80-masks}
  \end{minipage}\hfill
    \begin{minipage}[b]{0.40\linewidth}
    \begin{center}
      \centering \includegraphics[scale=0.8]{figures/wsim_m25p80.eps}
    \end{center}
    \caption{M25P80 pins configuration}
    \label{wsim-m25p80}
  \end{minipage}
\end{table}

\medskip
Thus, writing CS and HOLD pins might be implement like this:
\begin{verbatim}
uint32_t value = 0000 0110 0000 0000;
machine.device[FLASH].write(FLASH, M25P_H | M25P_S, value);
\end{verbatim}

\subsubsection{USART}
On the MSP430, USART may be configured in three modes: SPI, UART and I2C. However I2C is not implemented in WSim yet.\\

The WSim simulation of USART does not follow exactly the real hardware running. Indeed instead of sending data bit by bit to devices, WSim USART transmits byte by byte, in simulating the time to send one byte. Hence a byte is only ready to be transmitted after 8 UCLK cycles have been counting. The same method is used for USART data reception from devices.
It allows to simplify USART transfer implementation and to save computation time by avoiding functions calls.\\

This choice of implementation has no effects on the reliability of the simulation.


\subsubsection{SPI particularity}
SPI bus works always in full duplex, that is to say every time data is transmitted to a SPI device, this one sends a synchronized response at the same time. Thus, in order to get data from a SPI device if nothing has to be transfered to it, you must send a dummy data to trigger the device response.\\

In WSim, SPI interface is implemented in the \verb$arch/msp430/msp430_usart.c$ file for the MSP430 MCU. This implementation do not check if SPI communication are full duplex. It may be done in your platform or in your device code.\\

The better way to implement SPI full duplex communications, is to take it into consideration in your device model code. As soon as your device \verb$YOURDEVICENAME_write()$ function is called by your platform for SPI writings, data must be immediately available for \verb$YOURDEVICENAME_read()$ function.

Indeed, as explained in subsection \ref{platform-update} page \pageref{platform-update}, the \verb$device_update()$ function of the platform performs writings (on devices, so readings on MCU), readings (on devices, so writings on MCU), and finally update devices.\\

However all devices models may not be implemented in that way. For some devices (cc2420, cc1100, ...), writing on their SPI input (SI) is taken into consideration only when the device is updated at the end of a updating platform cycle. As the reading action is performed after the writing one, no response is sent on the device SPI output (SO) yet.\\

This leads to a small lag between the simulation and the reality, since the SPI UxRXBUF register receives the response on the next \verb$device_update()$ call, that is to say few MCU cycles later (from 1 to 6).
The figure~\ref{wsim-spi-communication} illustrates that.\\

\begin{figure}[!h]
\begin{center}
  \includegraphics[scale=1]{figures/wsim_spi.eps}
\end{center}
\caption{WSim SPI and device communication particular case}
\label{wsim-spi-communication}
\end{figure}

In most cases this small lag will not be annoying.


\subsection{Making your device model compilable}
The procedure to make your device model compilable is quite similar to the platform one (please refer to the subsection \ref{platform-compilation} page \pageref{platform-compilation} for more details). Thus you have to modify these following files to compile your device : \verb$./configure.ac$, \verb$./devices/Makefile.am$, \verb$./devices/YOURDEVICEFOLDER/Makefile.am$.

\subsubsection{/configure.ac}
Add the path to your device makefile into \verb$AC_CONFIG_FILES$ of the output part: 
\begin{verbatim}
devices/YOURDEVICEFOLDER/Makefile
\end{verbatim}

\subsubsection{/devices/Makefile.am}
Simply add the name of your platform directory in the \verb$SUBDIRS$ variable.
\begin{verbatim}
SUBDIRS =   \
    7seg    \
    at45db  \
    bargraph\
    cc1100  \
    cc2420  \
    ds2411  \
    gdm1602a\
    hd44780 \
    led     \
    m25p80  \
    ptty    \
    uigfx   \
    yourdevicename
\end{verbatim}

\subsubsection{/devices/YOURDEVICEFOLDER/Makefile.am}
Compilation of your device model source has to build a static library \verb$*.a$, to make it reusable.
\begin{enumerate}
  \item First set the name of your device library and require it not be installed:
\begin{verbatim}
noinst_LIBRARIES=libyourdevicename.a
\end{verbatim}

  \item Next add this line to give additional preprocessor arguments (here it enables to include /wsim top directory at compilation):
\begin{verbatim}
INCLUDES=-I$(top_srcdir)
\end{verbatim}

  \item Declare the name of your device model source files, for example:
\begin{verbatim}
libled_a_SOURCES=yourdevicename_source1.h yourdevicename_source1.c\
                 yourdevicename_source2.h yourdevicename_source2.c\
                 yourdevicename_source3.h yourdevicename_source4.h\
\end{verbatim}

\end{enumerate}

\section{Special device}
\subsection{Pseudo serial PTTY}


\section{Microcontroller}


\chapter{Debugging WSim}

There are several methods to debug WSim code source.

\section{wsim.log file}

At each simulation a log file is generated by WSim, named wsim.log and located in the directory where WSim has been launched. This file contains debugging information.
To enable debugging information, you have to define the macro DEBUG. There are two ways to do so:

\begin{itemize}
  \item when launching \verb$configure$ file before compiling WSim add the option \verb$./configure --enable-debug$;
  \item or define directly the macro \verb$DEBUG$ in the WSim file \verb$xxx_debug.h$ located in the same directory than the file you want to debug, as shown in the following example:
\end{itemize}

\begin{verbatim}
/**
 *  \file   cc2420_debug.h
 *  \brief  CC2420 debug messages 
 *  \author Nicolas Boulicault
 *  \date   2007
 **/

/*
 *  cc1100_debug.h
 *  
 *
 *  Created by Nicolas Boulicault on 04/06/07.
 *  Copyright 2007 __WorldSens__. All rights reserved.
 *
 */

#ifndef _CC2420_DEBUG_H_
#define _CC2420_DEBUG_H_

/***************************************************/
/***************************************************/
/***************************************************/

#define DEBUG
#if defined(DEBUG)
#define CC2420_DEBUG(x...)     VERBOSE(2,x)
#define CC2420_DBG_RX(x...)    VERBOSE(2,x)
#define CC2420_DBG_TX(x...)    VERBOSE(2,x)
#else
#define CC2420_DEBUG(x...)     do { } while (0)
#define CC2420_DBG_RX(x...)    do { } while (0)
#define CC2420_DBG_TX(x...)    do { } while (0)
#endif

/***************************************************/
/***************************************************/
/***************************************************/

#define CC2420_PINS_DEBUG

\end{verbatim}

The second method has the advantage to print only debug messages of the file where \verb$DEBUG$ is defined, contrary to the first one that behaves like \verb$DEBUG$ were defined in each file of the program.

By default, debugging information in wsim.log file is minimal.(default verbose level equal to 0). Nevertheless more information may be output be increasing verbose level when starting simulation: \verb$--verbose=6$ for instance.
In the previous code, we have \verb$#define CC2420_DBG_RX(x...)    VERBOSE(2,x)$. This means that the \verb$CC2420_DBG_RX$ will be print in the wsim.log file only if the verbose level is superior or equal to 2.

Thus you understand that it is quite easy to add your own debug informations, if you need. You just have to define the print debugging function with its verbose level at the beginning of your file (or its associated *.h file). Then insert it with appropriate debugging message (a \verb$printf()$ function) at the right place.

Notice that the \verb$wsim.log$ file name may be changed into \verb$NAMEOFYOURCHOICE.log$ by using the option \verb$--logfile=NAMEOFYOURCHOICE.log$.

\section{ERROR() function}
The \verb$ERROR()$ function is closed to the \verb$VERBOSE()$ function, excepted that its result is printed in the wsim.log file and in the standard error output too, that is to say the terminal you launch WSim.
You can insert \verb$ERROR()$ function where you want without needs to declare it. Its syntax is as a \verb$printf()$ function.
Moreover some ERROR messages are printed only if the macro \verb$DEBUG_ME_HARDER$ is defined:
\begin{verbatim}
#if defined(DEBUG_ME_HARDER)
	    ERROR("senslab:devices: read data on radio while not in SPI mode ?\n");
#endif
\end{verbatim}

\section{Wsim trace}
The \verb$tracer_event_record()$ function, insered in the Wsim code, allows to save states of a variable during the simulation. To enable the trace storage, you just have to add the following option when starting a simulation: \verb$--trace$ (example: \verb$wsim-wsn430 --ui --trace --mode=time --modearg=100000000000$ \verb$wsn430-leds.elf$). The trace is then stored in the \verb$wsim.trc$ file and located in the  directory where WSim has been launched.

To make the wsim.trc file usable, you have to convert it with the external wtracer application, according to the following syntax. For instance:
\begin{itemize}
  \item\verb$wtracer --in=wsim.trc --out=wsim.gp --format=gplot$ gererates the gnuplot wsim.gp file. 
  \item\verb$wtracer --in=wsim.trc --out=wsim.vcd --format=vcd$ gererates the vcd wsim.vcd file, readable by GTKwave.
\end{itemize}


\section{Using GDB}
It is also possible to debug WSim by using GDB. Launch GDB in the folder where the *.elf file is located, set your breakpoints, and execute the run command followed by the WSim arguments, including your *.elf file. Here is an example:
\begin{verbatim}
loic@loic-laptop:~/Documents/Senstools/temp/senslab/node/wsn430_SW/wsn430-drivers/
wsn430-cc2420\$ gdb wsim-senslabv14
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu"...
(gdb) b main.c:200
Breakpoint 1 at 0x8054568: file main.c, line 200.
(gdb) r cc2420-tx.elf 
Starting program: /usr/local/bin/wsim-senslabv14 cc2420-tx.elf
[Thread debugging using libthread_db enabled]
[New Thread 0xb7c168c0 (LWP 23589)]
[Switching to Thread 0xb7c168c0 (LWP 23589)]

Breakpoint 1, main (argc=2, argv=0xbf976f24) at main.c:200
200	  options_start();
(gdb) n
201	  ui_options_add();
(gdb) 
\end{verbatim}


\chapter{Appendix}

\section{Abbreviations}
\begin{description}
  \item \textbf{ACLK} = Auxiliary Clock (of the MCU)
  \item \textbf{CS} = Chip Select
  \item \textbf{GPIO} = General Purpose Input Output
  \item \textbf{I2C} = Inter Integrated Circuit
  \item \textbf{IO} = Input Ouput
  \item \textbf{IRQ} = Interrupt Request
  \item \textbf{LPM} = Low Power Mode (for the MCU)
  \item \textbf{MCLK} = Master Clock (of the MCU)
  \item \textbf{MCU} = MicroController Unit
  \item \textbf{PTTY} = Pseudo Terminal Type
  \item \textbf{SI} = SPI device input
  \item \textbf{SMCLK} = Sub Main Clock (of the MCU)
  \item \textbf{SO} = SPI device output
  \item \textbf{SPI} = Serial Peripheral Interface
  \item \textbf{UART} = Universal Asynchronous Receiver Transmitter
  \item \textbf{UCLK} = Uncore Clock
  \item \textbf{UI} = User Interface
  \item \textbf{USART} = Universal Synchronous/Asynchronous Receiver Transmitter
  \item \textbf{UxRXBUF} = SPI register used for reception
  \item \textbf{UxTXBUF} = SPI register used for transmission
\end{description}



\end{document}          
